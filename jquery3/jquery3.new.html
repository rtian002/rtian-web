<link rel="stylesheet" href="css/a.css" >
<script src="js/rtian.index.js" ></script>
<script type="text/javascript">
	$('.article_index a[pot]').click(function(){
	var pot=$(this).attr("pot");
	$("article").mCustomScrollbar("scrollTo",pot);

});

</script>
<header class="top-nav">
	<a href="#index.html" title="">首页</a>&nbsp;&gt;&nbsp; <span class="sub-title">其他</span> &nbsp;&gt;&nbsp;jQuery3新特性
	<a class="source" href="#source.html" >关于文档</a>
</header>

  <article class="post-5535 post type-post status-publish format-standard hentry category-news tag-jquery inner-box" id="post-5535">
   <div class="panel-body">
    <div class="entry-header page-header">
     <h2 class="entry-title h3" itemprop="name">jQuery3.0 API升级与新增jquery特性</h2>
    </div>
    <div class="entry-content" data-no-instant="" itemprop="articleBody">
     <div class="article_index">
      <h5>文章目录<span class="caret"></span></h5>
      <ul>
       <li><a href="javascript:void(0)" pot="#t1">新增特性</a>
        <ul>
         <li><a href="javascript:void(0)" pot="#t2"><code>for...of</code> 循环</a></li>
         <li><a href="javascript:void(0)" pot="#t3"><code>$.get()</code> 和 <code>$.post()</code> 函数的新签名</a></li>
         <li><a href="javascript:void(0)" pot="#t4">采用 <code>requestAnimationFrame()</code> 来实现动画</a></li>
         <li><a href="javascript:void(0)" pot="#t5"><code>unwrap()</code> 方法</a></li>
        </ul></li>
       <li><a href="javascript:void(0)" pot="#t6">有变更的特性</a>
        <ul>
         <li><a href="javascript:void(0)" pot="#t7"><code>:visible</code> 和 <code>:hidden</code></a></li>
         <li><a href="javascript:void(0)" pot="#t8"><code>data()</code> 方法</a></li>
         <li><a href="javascript:void(0)" pot="#t9"><code>Deferred</code> 对象</a></li>
         <li><a href="javascript:void(0)" pot="#t10">SVG 文档</a></li>
        </ul></li>
       <li><a href="javascript:void(0)" pot="#t11">已废弃、已移除的方法和属性</a>
        <ul>
         <li><a href="javascript:void(0)" pot="#t12">废弃 <code>bind()</code>、<code>unbind()</code>、<code>delegate()</code> 和 <code>undelegate()</code> 方法</a></li>
         <li><a href="javascript:void(0)" pot="#t13">移除 <code>load()</code>、<code>unload()</code> 和 <code>error()</code> 方法</a></li>
         <li><a href="javascript:void(0)" pot="#t14">移除 <code>context</code>、<code>support</code> 和 <code>selector</code> 属性</a></li>
        </ul></li>
       <li><a href="javascript:void(0)" pot="#t15">已修复的 Bug</a>
        <ul>
         <li><a href="javascript:void(0)" pot="#t16"><code>width()</code> 和 <code>height()</code> 的返回值将不再取整</a></li>
         <li><a href="javascript:void(0)" pot="#t17"><code>wrapAll()</code> 方法</a></li>
        </ul></li>
       <li><a href="javascript:void(0)" pot="#t18">如何下载 jQuery 3 beta 1</a></li>
       <li><a href="javascript:void(0)" pot="#t19">结论</a></li>
       <li><a href="javascript:void(0)" pot="#t20">译注</a></li>
      </ul>
     </div>
     <p>jQuery 的横空出世，至今已有十个年头了，而它的长盛不衰显然不是没有理由的。jQuery 提供了极为友好的接口，使得开发者们可以方便地进行 DOM 操作、发起 <span class="wp_keywordlink"><a title="ajax" href="http://caibaojian.com/t/ajax">ajax</a></span> 请求、生成动画……不一而足。此外，与 DOM API 不同的是，jQuery 采用了 “混合模式”。这意味着你可以在任何一个 jQuery 集合身上调用 jQuery 方法，而不用关心它到底包含了几个元素（不管是零个、一个或多个，都没问题）。</p>
     <p>在未来的几周内，jQuery 就将抵达一个重要的里程碑——正式发布 3.0 版本。jQuery 3 修复了大量的 bug，增加了新的方法，同时移除了一些接口，并修改了少量接口的行为。在这篇文章中，我将为大家重点讲解 jQuery 3 所引入的那些最重要的变化。</p>
	 <p class="img"><img src="images/jquery.png" ></p>
     <h3 id="t1"><a name="t1"></a>新增特性</h3>
     <p>我们先来讨论 jQuery 3 中最重要的几个新增特性。</p>
     <h4 id="t2"><a name="t2"></a><code>for...of</code> 循环</h4>
     <p>在 jQuery 3 中，我们可以用 <code>for...of</code> 循环语句来迭代一个 jQuery 集合中的所有 DOM 元素。这种新的迭代方法是 ECMAScript 2015（即 ES6）规范中的一部分。这个方法可以对 “可迭代对象”（比如 <code>Array</code>、<code>Map</code>、<code>Set</code> 等）进行循环。</p>
     <p>当使用这种新的迭代方法时，你在循环体内每次拿到的值并不是一个 jQuery 对象，而是一个 DOM 元素（译注：这一点跟 <code>.each()</code> 方法类似）。当你在对一个 jQuery 集合进行操作时，这个新的迭代方法可以少许改善你的<span class="wp_keywordlink"><a title="代码" href="http://caibaojian.com/c/code">代码</a></span>。</p>
     <p>为了搞清楚这种迭代方法到底是怎么工作的，我们来假设一个场景——你需要给页面中的每个 <code>input</code> 元素分配一个 ID。在 jQuery 3 之前，你可能会这样写：</p>
     <pre><code class="hljs language-js"><span class="hljs-keyword">var</span> $inputs = $(<span class="hljs-string">'input'</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; $inputs.length; i++) {
 &nbsp; $inputs[i].id = <span class="hljs-string">'input-'</span> + i;
}</code></pre>
     <p>而在 jQuery 3 中，你就可以这样写了：</p>
     <pre><code class="hljs language-js"><span class="hljs-keyword">var</span> $inputs = $(<span class="hljs-string">'input'</span>);<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; 

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> input of $inputs) {
 &nbsp; input.id = <span class="hljs-string">'input-'</span> + i++;
}</code></pre>
     <p>（译注：其实 jQuery 自己是有个 <code>.each()</code> 方法的，可读性也不赖。）</p>
     <h4 id="t3"><a name="t3"></a><code>$.get()</code> 和 <code>$.post()</code> 函数的新签名</h4>
     <p>jQuery 3 为 <code>$.get()</code> 和 <code>$.post()</code> 这两个工具函数增加了新签名，从而使得它们和 <code>$.ajax()</code> 的接口风格保持一致。新签名是这样的：</p>
     <pre><code class="hljs language-js">$.get([settings])

$.post([settings])</code></pre>
     <p><code>settings</code> 是一个对象，它包含多个属性。它的格式和你以前传给 <code>$.ajax()</code> 的参数格式是一样的。如果你想更清楚地了解这个参数对象，请参考 <code>$.ajax()</code> 页面 中的相关描述。</p>
     <p><code>$.get()</code> 和 <code>$.post()</code> 的参数对象与传给 <code>$.ajax()</code> 的参数相比，唯一的区别就是前者的 <code>method</code> 属性总是会被忽略。原因其实也很简单，<code>$.get()</code> 和 <code>$.post()</code> 本身就已经预设了发起 Ajax 请求的 <span class="wp_keywordlink"><a title="http" href="http://caibaojian.com/t/http">HTTP</a></span> 方法了（显然 <code>$.get()</code> 就是 GET，而 <code>$.post()</code> 就是 POST）。也就是说，正常人类应该是不会想用 <code>$.get()</code> 方法来发送一个 POST 请求的。</p>
     <p>假设有以下一段代码：</p>
     <pre><code class="hljs language-js">$.get({
 &nbsp; &nbsp;url: <span class="hljs-string">'https://www.audero.it'</span>,
 &nbsp; &nbsp;method: <span class="hljs-string">'POST'</span> <span class="hljs-comment">// This property is ignored</span>
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 这个属性将被忽略</span>});</code></pre>
     <p>不管我们把 <code>method</code> 属性写成什么，这个请求总是会以 GET 的方式发出去的。</p>
     <h4 id="t4"><a name="t4"></a>采用 <code>requestAnimationFrame()</code> 来实现动画</h4>
     <p>所有现代浏览器（包括 IE10 及以上）都是支持 <code>requestAnimationFrame</code> 的。jQuery 3 将会在内部采用这个 API 来实现动画，以便达到更流畅、更省资源的动画效果。</p>
     <h4 id="t5"><a name="t5"></a><code>unwrap()</code> 方法</h4>
     <p>jQuery 3 为 <code>unwrap()</code> 方法增加了一个可选的 selector 参数。这个方法的新签名是这样的：</p>
     <pre><code class="hljs language-js">unwrap([selector])</code></pre>
     <p>有了这个特性，你就可以给这个方法传入一个包含选择符表达式的字符串，用它来在父元素内进行匹配。如果存在匹配的子元素，则这个子元素的父层将被解除；如果没有匹配，则不进行操作。</p>
     <h3 id="t6"><a name="t6"></a>有变更的特性</h3>
     <p>jQuery 3 还修改了一些特性的行为。</p>
     <h4 id="t7"><a name="t7"></a><code>:visible</code> 和 <code>:hidden</code></h4>
     <p>jQuery 3 将会修改 <code>:visible</code> 和 <code>:hidden</code> 过滤器的含义。只要元素具有任何布局盒，哪怕宽高为零，也会被认为是 <code>:visible</code>。举个例子，<code>br</code> 元素和不包含内容的行内元素现在都会被 <code>:visible</code> 这个过滤器选中。</p>
     <p>因此，如果你的页面中包含如下的结构：</p>
     <pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">br</span> /&gt;</span></code></pre>
     <p>然后运行以下语句：</p>
     <pre><code class="hljs language-js"><span class="hljs-built_in">console</span>.log($(<span class="hljs-string">'body :visible'</span>).length);</code></pre>
     <p>在 jQuery 1.x 和 2.x 中，你得到的结果会是 <code>0</code>；但在 jQuery 3 中，你会得到 <code>2</code>。</p>
     <h4 id="t8"><a name="t8"></a><code>data()</code> 方法</h4>
     <p>另一个重要的变化是跟 <code>data()</code> 方法有关的。现在它的行为已经变得跟 Dataset API 规范 一致了。jQuery 3 将会把所有属性键名转换成驼峰形式。我们来详细看一下，以如下元素为例：</p>
     <pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span></code></pre>
     <p>当我们在用 jQuery 3 以前的版本时，如果运行如下代码：</p>
     <pre><code class="hljs language-js"><span class="hljs-keyword">var</span> $elem = $(<span class="hljs-string">'#container'</span>);

$elem.data({ &nbsp; <span class="hljs-string">'my-property'</span>: <span class="hljs-string">'hello'</span>});<span class="hljs-built_in">console</span>.log($elem.data());</code></pre>
     <p>将会在控制台得到如下结果：</p>
     <pre><code class="hljs language-js">{my-property: <span class="hljs-string">&quot;hello&quot;</span>}</code></pre>
     <p>而在 jQuery 3 中，我们将会得到如下结果：</p>
     <pre><code class="hljs language-js">{myProperty: <span class="hljs-string">&quot;hello&quot;</span>}</code></pre>
     <p>请注意，在 jQuery 3 中，属性名已经变成了驼峰形式，横杠已经被去除了；而在以前的版本中，属性名会保持全小写，并原样保留横杠。</p>
     <h4 id="t9"><a name="t9"></a><code>Deferred</code> 对象</h4>
     <p>jQuery 3 还改变了 <code>Deferred</code> 对象的行为。<code>Deferred</code> 对象可以说是 <code>Promise</code> 对象的前身之一，它实现了对 Promise/A+ 协议 的兼容。这个对象以及它的历史都相当有意思。如果想要深入了解，你可以去阅读 jQuery 官方文档，也可以去看我写的书《jQuery 实战（第三版）》——这本书也涵盖了 jQuery 3。</p>
     <p>在 jQuery 1.x 和 2.x 中，传给 <code>Deferred</code> 的回调函数内如果出现未捕获的异常，会立即中断程序的执行（译注：即静默失败，其实 jQuery 绝大多数回调函数的行为都是这样的）。而原生的 <code>Promise</code> 对象并非如此，它会抛出异常，并不断向上冒泡，直至到达 <code>window.onerror</code>（通常冒泡的终点是这里）。如果你没有定义一个函数来处理这个错误事件的话（通常我们都不会这么做），那这个异常的信息将会被显示出来，此时程序的执行才会停止。</p>
     <p>jQuery 3 将会遵循原生 <code>Promise</code> 对象的模式。因此，回调内产生的异常将会导致失败状态（rejection），并触发失败回调。一旦失败回调执行完毕，整个进程就将继续推进，后续的成功回调将被执行。</p>
     <p>为了让你更好地理解这个差异，让我们来看一个小例子。比如我们有如下代码：</p>
     <pre><code class="hljs language-js"><span class="hljs-keyword">var</span> deferred = $.Deferred();

deferred
 &nbsp;.then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ &nbsp; &nbsp;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'An error'</span>);
 &nbsp;})
 &nbsp;.then( &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Success 1'</span>);
 &nbsp; &nbsp;}, &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Failure 1'</span>);
 &nbsp; &nbsp;}
 &nbsp;)
 &nbsp;.then( &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Success 2'</span>);
 &nbsp; &nbsp;}, &nbsp; &nbsp;<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ &nbsp; &nbsp; &nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Failure 2'</span>);
 &nbsp; &nbsp;}
 &nbsp;);

deferred.resolve();</code></pre>
     <p>在 jQuery 1.x 和 2.x 中，只有第一个函数（也就是抛出错误的那个函数）会被执行到。此外，由于我们没有为 <code>window.onerror</code> 定义任何事件处理函数，控制台将会输出 “Uncaught Error: An error”，而且程序的执行将中止。</p>
     <p>而在 jQuery 3 中，整个行为是完全不同的。你将在控制台中看到 “Failure 1” 和 “Success 2” 两条消息。那个异常将会被第一个失败回调处理，并且，一旦异常得到处理，那么后续的成功回调将被调用。</p>
     <h4 id="t10"><a name="t10"></a>SVG 文档</h4>
     <p>没有哪一个 jQuery 版本（包括 jQuery 3）曾官方宣称支持 SVG 文档。不过事实上有很多方法<strong>是可以奏效的</strong>，此外还有一些方法在以前是不行的（比如操作类名的那些方法），但它们在 jQuery 3 中也得到了更新。因此，在 jQuery 3 中，你应该可以放心使用诸如 <code>addClass()</code> 和 <code>hasClass()</code> 这样的方法来操作 SVG 文档了。</p>
     <h3 id="t11"><a name="t11"></a>已废弃、已移除的方法和属性</h3>
     <p>在增加了上述改进的同时，jQuery 也移除、废弃了一些特性。</p>
     <h4 id="t12"><a name="t12"></a>废弃 <code>bind()</code>、<code>unbind()</code>、<code>delegate()</code> 和 <code>undelegate()</code> 方法</h4>
     <p>jQuery 在很久以前就引入了 <code>on()</code> 方法，它提供了一个统一的接口，用以取代 <code>bind()</code>、<code>delegate()</code> 和 <code>live()</code> 等方法。与此同时，jQuery 还引入了 <code>off()</code> 这个方法来取代 <code>unbind()</code>、<code>undelegated()</code> 和 <code>die()</code> 等方法。从那时起，<code>bind()</code>、<code>delegate()</code>、<code>unbind()</code> 和 <code>undelegate()</code> 就已经不再推荐使用了，但它们还是一直存在着。</p>
     <p>jQuery 3 终于开始将这些方法标记为 “废弃” 了，并计划在未来的某个版本（很可能是 jQuery 4）中将它们彻底移除。因此，请在你的项目中统一使用 <code>on()</code> 和 <code>off()</code> 方法，这样你就不用担心未来版本的变更了。</p>
     <h4 id="t13"><a name="t13"></a>移除 <code>load()</code>、<code>unload()</code> 和 <code>error()</code> 方法</h4>
     <p>jQuery 3 彻底抛弃了 <code>load()</code>、<code>unload()</code> 和 <code>error()</code> 等已经标记为废弃的方法。这些方法在很早以前（从 jQuery 1.8 开始）就已经被标记为废弃了，但一直没有去掉。如果你正在使用的某款插件仍然依赖这些方法，那么升级到 jQuery 3 会把你的代码搞挂。因此，在升级过程中请务必留意。</p>
     <h4 id="t14"><a name="t14"></a>移除 <code>context</code>、<code>support</code> 和 <code>selector</code> 属性</h4>
     <p>jQuery 3 彻底抛弃了 <code>context</code>、<code>support</code> 和 <code>selector</code> 等已经标记为废弃的属性。同上，在升级到 jQuery 3 时，请留意你正使用的插件。</p>
     <h3 id="t15"><a name="t15"></a>已修复的 Bug</h3>
     <p>jQuery 3 修复了以往版本中的一些非常重要的 bug。在本节中，我将着重介绍其中两处，因为这两者应该会对你写代码的习惯带来显著影响。</p>
     <h4 id="t16"><a name="t16"></a><code>width()</code> 和 <code>height()</code> 的返回值将不再取整</h4>
     <p>jQuery 3 修复了 <code>width()</code>、<code>height()</code> 和其它相关方法的一个 bug。这些方法的返回值将不再舍入取整，因为这种取整行为在某些情况下不便于对元素进行定位。</p>
     <p>我们来详细看一看。假设你一个宽度为 <code>100px</code> 的容器元素，它包含了三个子元素，宽度均为三分之一（即 33.333333%）：</p>
     <pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;container&quot;</span>&gt;</span>
 &nbsp; <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>My name<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
 &nbsp; <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>is<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
 &nbsp; <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>Aurelio De Rosa<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span></code></pre>
     <p>在 jQuery 3 以前的版本中，如果你尝试通过以下代码来获取子元素的宽度……</p>
     <pre><code class="hljs language-js">$(<span class="hljs-string">'.container div'</span>).width();</code></pre>
     <p>……那么你得到结果将是 <code>33</code>。原因在于 jQuery 会把 33.33333 这个值取整。而在 jQuery 3 中，这个 bug 已经被修复了，因此你将会得到更加精确的结果（即一个浮点数）。</p>
     <h4 id="t17"><a name="t17"></a><code>wrapAll()</code> 方法</h4>
     <p>jQuery 3 还修复了 <code>wrapAll()</code> 方法中的一个 bug，这个 bug 出现在把一个函数作为参数传给它的情况下。在 jQuery 3 以前的版本中，当一个函数被传给 <code>wrapAll()</code> 方法时，它会把 jQuery 集合中的每个元素单独包裹起来。换句话说，这种行为和把一个函数传给 <code>wrap()</code> 时的行为是完全一样的。</p>
     <p>在修复这个问题的同时，还引入了另外一个变更：由于在 jQuery 3 中，这个函数只会调用一次了，那就无法把 jQuery 集合中每个元素都传给它。因此，这个函数的执行上下文（<code>this</code>）将只能指向当前 jQuery 集合中的第一个元素。</p>
     <h3 id="t18"><a name="t18"></a>如何下载 jQuery 3 beta 1</h3>
     <p>既然你已经读到了这里，那说明你很可能想试试 jQuery 3 的第一个 beta 测试版。你可以通过以下两个地址来获取这个版本：</p>
     <ul class=" list-paddingleft-2">
      <li>未压缩版： <span class="wp_keywordlink"><a href="https://code.jquery.com/jquery-3.0.0.js">https://code.jquery.com/jquery-3.0.0.js</a></span></li>
      <li>压缩版： <span class="wp_keywordlink"><a href="https://code.jquery.com/jquery-3.0.0.min.js">https://code.jquery.com/jquery-3.0.0.min.js</a></span></li>
     </ul>
     <p>当然，你还可以通过 npm 来下载：</p>
     <pre><code class="hljs language-sh">npm install jquery@<span class="hljs-number">3.0</span>.<span class="hljs-number">0</span></code></pre>
     <h3 id="t19"><a name="t19"></a>结论</h3>
     <p>很多人一直在唱衰 jQuery，说它在现代网页开发中已经没有一席之地了。但不管怎样，jQuery 的开发仍在继续，客观的统计数据（在排名前一百万名的网站中占有率高达 78.5%）也让这些论调不攻自破。</p>
     <p>在本文中，我已经带你了解了一遍 jQuery 3 将会带来的一些重大变化。或许你已经察觉到了，这个版本并不太可能搞挂你的既有项目，因为它引入的破坏性变更其实寥寥无几。不过，在升级到 jQuery 3 的过程中，你还是有必要牢记一些关键点，比如 <code>Deferred</code> 对象的改进等等。同样，在升级某个第三方库时，也有必要检查一下该项目的兼容性情况，以便尽早发现任何非预期行为，避免某些功能失效。</p>
     <hr />
     <h3 id="t20"><a name="t20"></a>译注</h3>
     <p>除了本文所提及的变更之外，jQuery 3.0 最大的变化就是<strong>彻底放弃对 IE8 的支持</strong>。jQuery 团队做出这个决定的原因在于，微软已经在今年年初宣布停止对 IE 8～10 的支持。因此，jQuery 在 3.0 alpha 阶段所发布的 jQuery Compat 项目也就没有继续存在的必要了。</p>
     <p>不过，由于 IE8 仍然是中国大陆最流行的浏览器之一，对国内的开发者来说，在短期（甚至中期）内还不得不停留在 jQuery 1.x 版本。</p>
     <p>好吧，最后还是说个好消息吧。为帮助用户平滑升级，此次 jQuery 同样会为 3.0 版本提供迁移插件（jQuery Migrate plugin）。在把 jQuery 升级到 3.0 之后同时运行这个插件，即可确保基于 jQuery 1.x 或 2.x 的既有业务代码正常运行；同时，它还将在控制台向你报告既有代码与 jQuery 3 不兼容的地方。当你修复了这些不兼容问题之后，就可以安全地移除这个插件了。</p>
    </div>
   </div>

  </article>
